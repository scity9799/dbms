-- 1번 : 조인

-- 1. 내부조인
CREATE TABLE TBL_BOOKS(
	BOOK_ID CHAR(3),
	BOOK_TITLE VARCHAR2(1000),
	BOOK_AUTHOR VARCHAR2(100),
	CONSTRAINT BOOK_PK PRIMARY KEY (BOOK_ID)
);

SELECT * FROM TBL_BOOKS;

CREATE TABLE TBL_BOOKPRICE(
	BP_ID CHAR(3),
	BP_PRICE NUMBER,
	CONSTRAINT BP_PK PRIMARY KEY (BP_ID)
);

SELECT * FROM TBL_BOOKPRICE;

INSERT INTO TBL_BOOKS 
--VALUES(1, '위대한 개츠비', 'F.스콧 피츠제럴드');
--VALUES(2, '해리포터와 마법사의 돌', 'J.K. 롤링');
--VALUES(3, '1984', '조지오웰');
--VALUES(4, '오만과 편견', '제인 오스틴');
--VALUES(5, '데미안', '헤르만 헤세');
--VALUES(6, '모모', '미하엘 엔더');
--VALUES(7, 'DBMS완전정복', 'DBMS');

INSERT INTO TBL_BOOKPRICE
--VALUES(1, 15000);
--VALUES(2, 18000);
--VALUES(3, 14000);
--VALUES(4, 17000);
--VALUES(5, 18000);
--VALUES(6, 20000);
--VALUES(7, 20000);

SELECT * FROM TBL_BOOKS;
SELECT * FROM TBL_BOOKPRICE;

-- 2개의 테이블 내부 조인(등가조인)
SELECT BOOK_ID, BOOK_TITLE, BOOK_AUTHOR, BP_ID, BP_PRICE
FROM TBL_BOOKS A INNER JOIN TBL_BOOKPRICE B
ON A.BOOK_ID = B.BP_ID;

DROP TABLE TBL_BOOKS;
DROP TABLE TBL_MEMBERS;

-- 도서관
-- 도서, 회원, 렌탈(증긴테이블로 사용)
CREATE TABLE TBL_BOOKS(
	BOOKS_ID NUMBER,
	BOOKS_TITLE VARCHAR2(100),
	BOOKS_AUTHOR VARCHAR2(100),
	CONSTRAINT BOOKS_PK PRIMARY KEY (BOOKS_ID)
);

CREATE TABLE TBL_MEMBERS(
	MEM_ID NUMBER,
	MEM_NAME VARCHAR2(100),
	MEM_PHONE VARCHAR2(100),
	MEM_EMAIL VARCHAR2(100),
	CONSTRAINT MEMBERS_PK PRIMARY KEY (MEM_ID)
);

CREATE TABLE TBL_RENTAL(
	REN_ID NUMBER,
	MEM_ID NUMBER,
	BOOKS_ID NUMBER,
	REN_RENTAL_DATE DATE,
	REN_RETURN_DATE DATE,
	CONSTRAINT RENTAL_PK PRIMARY KEY (REN_ID),
	CONSTRAINT RENTAL_BOOKS_FK FOREIGN KEY (BOOKS_ID) REFERENCES TBL_BOOKS(BOOKS_ID),
	CONSTRAINT RENTAL_MEMBERS_FK FOREIGN KEY (MEM_ID) REFERENCES TBL_MEMBERS(MEM_ID)
);

SELECT * FROM TBL_RENTAL;
SELECT * FROM TBL_BOOKS;
SELECT * FROM TBL_MEMBERS;

INSERT INTO TBL_BOOKS
--VALUES(1, '위대한 개츠비', 'F.스콧 피츠제럴드');
--VALUES(2, '해리포터와 마법사의 돌', 'J.K. 롤링');
--VALUES(3, '1984', '조지오웰');
--VALUES(4, '오만과 편견', '제인 오스틴');
--VALUES(5, '데미안', '헤르만 헤세')

INSERT INTO TBL_MEMBERS VALUES
--(1, '짱구', '123-456-7890', 'aaa@koreait.com');
--(2, '유리', '987-654-3210', 'bbb@koreait.com');
--(3, '철수', '555-123-4567', 'ccc@koreait.com');
--(4, '훈이', '777-888-9999', 'ddd@koreait.com');
--(5, '맹구', '555-777-3333', 'eee@koreait.com');

INSERT INTO TBL_RENTAL VALUES
--(1, 1, 3, TO_DATE('2023-12-11', 'YYYY-MM-DD'), TO_DATE('2023-12-18', 'YYYY-MM-DD'));
--(2, 2, 1, TO_DATE('2023-12-11', 'YYYY-MM-DD'), TO_DATE('2023-12-18', 'YYYY-MM-DD'));
--(3, 3, 2, TO_DATE('2023-12-13', 'YYYY-MM-DD'), TO_DATE('2023-12-20', 'YYYY-MM-DD'));
--(4, 4, 4, TO_DATE('2023-12-20', 'YYYY-MM-DD'), TO_DATE('2023-12-27', 'YYYY-MM-DD'));
--(5, 5, 5, TO_DATE('2023-12-22', 'YYYY-MM-DD'), TO_DATE('2023-12-29', 'YYYY-MM-DD'));

SELECT * FROM TBL_RENTAL;
SELECT * FROM TBL_BOOKS;
SELECT * FROM TBL_MEMBERS;

-- 등가조인 : 2개 이상의 테이블을 조인할 때 특정 컬럼들의 값이 서로 같은 행만 결과로 반환

-- 대여정보와 책의저자를 조회하는 등가조인
-- 1) 행의 개수를 먼저 파악하여 선행테이블인지 후행테이블인지 결정
SELECT COUNT(*)
--FROM TBL_RENTAL tr; -- 5행
--FROM TBL_BOOKS; -- 5행
FROM TBL_MEMBERS; -- 5행

-- 2) 조인을 사용하여 2개의 테이블 조회
SELECT REN_RENTAL_DATE, REN_RETURN_DATE, BOOKS_AUTHOR, TB.BOOKS_ID 
FROM TBL_BOOKS TB INNER JOIN TBL_RENTAL tr 
-- 3) 2개의 테이블에서 일치하는 컬럼을 확인 후 ON절에 추가
ON TB.BOOKS_ID = TR.BOOKS_ID ;

-- 회원의 이름과 대여한 책의 제목을 가져오는 등가조인
-- 1) 선행테이블과 후행테이블 확인
SELECT COUNT(*)
--FROM TBL_MEMBERS tm ; -- 5행
--FROM TBL_BOOKS tb ; -- 5행
FROM TBL_RENTAL tr  ; -- 5행

-- 정확히 같은 값을 가진 데이터로만 조회 1=1, 2=2
SELECT TB.BOOKS_TITLE , TM.MEM_NAME
FROM TBL_BOOKS tb JOIN TBL_MEMBERS tm 
ON TB.BOOKS_ID = TM.MEM_ID ;

SELECT * FROM TBL_RENTAL tr ;
SELECT * FROM TBL_BOOKS tb ;

-- 조인을 2번 사용해야한다
-- 누가 어떤 책을 빌렸는지 조회
SELECT TM.MEM_NAME, TB.BOOKS_TITLE, TM.MEM_ID, TB.BOOKS_ID
FROM TBL_RENTAL tr
JOIN TBL_MEMBERS tm ON TR.MEM_ID = TM.MEM_ID -- 대여테이블 + 회원테이블 연결, 조건 : 빌린사람번호 = 회원번호(같은사람끼리 연결)
JOIN TBL_BOOKS tb ON TR.BOOKS_ID  = TB.BOOKS_ID ; -- 대여테이블 + 책테이블 연결, 조건 : 빌린책번호 = 책번호(같은책끼리 연결)
-- 대여 테이블을 기준으로 해서 회원테이블을 회원번호와 연결하고
-- 책테이블과 책번호를 연결해서
-- 책번호, 책제목, 회원번호, 최원이름을 가져와라

-- 책 대여일 - 반납일 사이에 특정 날짜가 포함되었는지 조회(2023-12-25)
SELECT TM.MEM_NAME, TB.BOOKS_TITLE , TR.REN_RENTAL_DATE, TR.REN_RETURN_DATE
FROM TBL_RENTAL TR
INNER JOIN TBL_BOOKS TB ON TR.BOOKS_ID = TB.BOOKS_ID
INNER JOIN TBL_MEMBERS tm ON TR.MEM_ID = TM.MEM_ID
WHERE TO_DATE('2023-12-25', 'YYYY-MM-DD') BETWEEN TR.REN_RENTAL_DATE AND TR.REN_RETURN_DATE;
--WHERE TR.RENTAL_DATE BETWEEN TO_DATE('2023-12-25','YYYY-MM-DD') AND TO_DATE('2023-12-25','YYYY-MM-DD')

-- [2] 비등가 조인 : 두 테이블 간의 조건이 같음이 아닌 범위 조건등을 사용하는 방식

-- 누가 어떤책을 얼마나 빌렸는지 보고 짧게 빌렸으면 단기대여 길면 장기대여로 조회(7일이하면 단기, 7일 초과면 장기)
SELECT TB.BOOKS_TITLE, TM.MEM_NAME, TR.REN_RENTAL_DATE, TR.REN_RETURN_DATE,
   CASE 
      WHEN TR.REN_RETURN_DATE - TR.REN_RENTAL_DATE <= 7
          THEN '단기대여'
      ELSE '장기대여'
   END
FROM TBL_RENTAL TR
JOIN TBL_BOOKS TB ON TR.BOOKS_ID = TB.BOOKS_ID 
JOIN TBL_MEMBERS tm ON TR.MEM_ID = TM.MEM_ID ;


--  BETWEEN A AND B, >= , <=
SELECT * FROM TBL_STU1;
SELECT * FROM TBL_ENROLL;

-- 성적 등급 확인
-- 학생 이름과 성적이 b이상인 행만 조회
SELECT S.STU_NAME, E.ENR_GRADE
FROM TBL_STU1 S JOIN TBL_ENROLL E ON S.STU_SID = E.ENR_SID   
WHERE E.ENR_GRADE IN ('A', 'B');

-- JOIN GRADE ON SCORE BETWEEN MIN AND MAX

-- 도서와 가격테이블을 조인해서 각 도서가 어느 가격 범주에 속하는지 조회하기
SELECT * FROM TBL_BOOKPRICE tb;
SELECT * FROM TBL_BOOKS;

CREATE TABLE TBL_PRICE_GRADE(
   GRADE_NAME VARCHAR2(20),
   MIN_PRICE NUMBER,
   MAX_PRICE NUMBER
);

INSERT INTO TBL_PRICE_GRADE VALUES('저가', 0, 5000);
INSERT INTO TBL_PRICE_GRADE
--VALUES('중가', 5001, 20000);
--VALUES('고가', 20001, 900000);

SELECT * FROM TBL_PRICE_GRADE;

SELECT  TB.BOOKS_TITLE, BP.BP_PRICE, PG.GRADE_NAME
FROM TBL_BOOKS TB JOIN TBL_BOOKPRICE BP ON TB.BOOKS_ID = BP.BP_ID
JOIN TBL_PRICE_GRADE PG ON BP.BP_PRICE BETWEEN PG.MIN_PRICE AND PG.MAX_PRICE;




-- 2. 외부조인

-- 테이블생성
CREATE TABLE TBL_STU1(
	STU_SID NUMBER,
	STU_NAME VARCHAR2(20),
	STU_MAJOR VARCHAR2(30),
	CONSTRAINT STU_PK PRIMARY KEY (STU_SID)
);

CREATE TABLE TBL_ENROLL(
	ENR_SID NUMBER,
	ENR_CID NUMBER,
	ENR_GRADE CHAR(2),
	CONSTRAINT ENROLL_PK PRIMARY KEY (ENR_SID, ENR_CID),
	CONSTRAINT ENROLL_STU1_FK FOREIGN KEY (ENR_SID) REFERENCES TBL_STU1(STU_SID)
	ON DELETE CASCADE 
	-- ON DELETE CASCADE 옵션 부모 테이블의 행이 삭제될 경우 자식 테이블의 관련된 행도 자동 삭제된다
);

SELECT * FROM TBL_ENROLL;
SELECT * FROM TBL_STU1;

-- 데이터 삽입
--INSERT INTO TBL_STU1 VALUES(1, '홍길동', '컴퓨터공학');
--INSERT INTO TBL_STU1 VALUES(2, '김영희', '컴퓨터공학');
--INSERT INTO TBL_STU1 VALUES(3, '이철수', '정보보안학');
--INSERT INTO TBL_STU1 VALUES(4, '신호동', '정보보안학');
--INSERT INTO TBL_STU1 VALUES(5, '신짱구', '정보보안학');

-- 데이터삽입
--INSERT INTO TBL_ENROLL VALUES(1, 101, 'A');
--INSERT INTO TBL_ENROLL VALUES(2, 102, 'B');
--INSERT INTO TBL_ENROLL VALUES(3, 101, 'C');
--INSERT INTO TBL_ENROLL VALUES(4, 102, 'A');
--INSERT INTO TBL_ENROLL VALUES(4, 101, 'B');

SELECT * FROM TBL_ENROLL;
SELECT * FROM TBL_STU1;

-- [1] 왼쪽 외부조인 LEFT OUTER JOIN
-- 모든 학생정보 기준으로 수강정보가 있는 경우 함께 출력하고 없는 경우 NULL 출력
SELECT STU_SID, STU_NAME, STU_MAJOR, ENR_CID, ENR_SID, ENR_GRADE
FROM TBL_STU1 S LEFT OUTER JOIN TBL_ENROLL te 
ON S.STU_SID = TE.ENR_SID ;

-- [2] 오른쪽 외부조인 RIGHT OUTER JOIN
-- 수강정보 기준으로 수강한 학생이 없는 경우에도 학생 정보는 NULL 출력(표시)
SELECT STU_SID, STU_NAME, STU_MAJOR, ENR_CID, ENR_SID, ENR_GRADE
FROM TBL_STU1 ts RIGHT JOIN TBL_ENROLL te 
ON ts.STU_SID = te.ENR_SID;

-- [3] 완전 외부조인 FULL OUTER JOIN
SELECT STU_SID, STU_NAME, STU_MAJOR, ENR_CID, ENR_SID, ENR_GRADE
FROM TBL_STU1 ts FULL JOIN TBL_ENROLL te 
ON ts.STU_SID = te.ENR_SID;



SELECT * FROM TBL_BOOKS;
SELECT * FROM TBL_BOOKPRICE;

INSERT INTO TBL_BOOKS 
--VALUES(8, '자바의 정석', '자바');
VALUES(10, '정보처리기사', '정처기');

-- 왼쪽 외부조인 모든컬럼 조회
SELECT TB. *, BP. *
FROM TBL_BOOKS tb LEFT JOIN TBL_BOOKPRICE BP
ON TB.BOOKS_ID = BP.BP_ID ;

-- 오른쪽 외부조인 모든컬럼 조회
SELECT TB. *, BP. *
FROM TBL_BOOKS tb RIGHT JOIN TBL_BOOKPRICE BP
ON TB.BOOKS_ID = BP.BP_ID ;

-- 완전 외부조인 모든컬럼 조회
SELECT TB. *, BP. *
FROM TBL_BOOKS tb FULL JOIN TBL_BOOKPRICE BP
ON TB.BOOKS_ID = BP.BP_ID ;

-- 3. 교차조인(CROSS JOIN)
SELECT TB. *, BP. *
FROM TBL_BOOKS tb CROSS JOIN TBL_BOOKPRICE BP; -- 7 X 7 = 48행이 나옴 

SELECT COUNT(*)
--FROM TBL_BOOKS; -- 7행
--FROM TBL_BOOKPRICE; -- 7행

-- 4. 셀프조인(SELF JOIN)
-- 직원과 그 매니저의 이름을 함께 출력
--SELECT E.EMPLOYEE_ID 직원ID, E.FIRST_NAME 직원이름,M.EMPLOYEE_ID 매니저번호, M.FIRST_NAME 매니저이름
SELECT E.EMPLOYEE_ID 직원ID, E.FIRST_NAME 직원이름, E.MANAGER_ID 매니저번호E, M.EMPLOYEE_ID , M.MANAGER_ID , M.FIRST_NAME 매니저이름
FROM HR.EMPLOYEES e LEFT JOIN HR.EMPLOYEES M
ON M.EMPLOYEE_ID  = E.MANAGER_ID ;
-- E : 직원의 매니저 번호 = M 매니저의 사원번호
-- E.MANAGER_ID => 상사번호
-- M.EMPLOYEE_ID => 실제 직원번호
SELECT * FROM EMPLOYEES e ;