day22 (DBMS 4일차)
복습 -> 이상현상 -> 정규화 -> DML2 -> 집계함수와 GROUP BY, HAVING

0. 복습
1) 데이터 무결성
	데이터가 정확하고 신뢰할 수 있게 유지되는 성질
	정확성 : 애매하지 않은 값
	일관성 : 사용자가 모든 같은 데이터 사용
	유효성 : 실제 존재하는 값

2) 무결성 종류
	개체무결성		모든 테이블은 PK 필요
	참조무결성		FK로 테이블간 관계유지
	도메인무결성	자료형, 범위, NULL 제한
	
3) 키(KEY)
	데이터를 구분/식별하기 위한 속성(컬럼)
	기본키(PK)	중복 X, NULL X
	외래키(FK)	다른 테이블의 PK 참조
	조합키		여러 컬럼을 묶은 키
	후보키		PK 후보	
	대체키		PK가 안 된 후보키
	슈퍼키		식별 가능한 모든 키

4) 제약조건
	PK		고유 + NULL 불가
	FK		참조관계
	UNIQUE		중복 X, NULL O
	CHECK		조건 제한
	NOT NULL	NULL X
	DEFAULT		기본값 설정

5) 모델링
	현실 -> 데이터 구조로 단순/명확/추상화 하는 과정
	구성 ->	엔티티 : 대상
		모델러 : 설계자

6) 모델링 단계
	요구사항분석 -> 개념적 설계(개념모델링) -> 논리적 설계(논리모델링) -> 물리적 설계(물리모델링) -> 구현

7) DDL / DML
	DDL : 데이터 정의어
		CREATE : 생성
		ALTER : 수정(테이블명 수정, 컬럼명 수정, 타입/용량(크기) 수정, 컬럼추가/삭제), 제약조건 추가/삭제) 
		DROP : 삭제
		TRUNCATE : 테이블의 데이터 삭제(초기화)
	
	DML : 데이터 조작어
		SELECT : 조회
		INSERT : 추가
		UPDATE : 수정
		DELETE : 삭제

1. 데이터베이스 모델링


# 1. 아래 요구사항을 분석하고 모델링 하시오(물리적모델링까지만 진행)

도서관에서 회원의 정보와 책의 정보가 필요하다.
회원의 정보는 회원번호, 이름, 나이, 핸드폰 번호, 주소가 필요하고
책의 정보는 도서번호, 책이름, 장르가 필요하다.
단, 장르는 인문학, 추리, IT, 로맨스
한 명의 회원은 여러권의 책을 빌릴 수 있다.
테이블 명 MEMBER, BOOK

### 요구사항 분석 : 무엇을 만들 것인가를 정리하는 단계(시스템 목적, 필요한 정보, 관계, 제약사항 정의)
   회원 테이블이 상위테이블, 책 테이블이 하위 테이블
   
   
   도서관에서 회원과 도서정보를 관리한다
   회원은 회원번호, 이름, 나이, 핸드폰번호, 주소가 필요하다
   도서는 도서번호, 책이름, 장르가 필요하다
   장르는 인문학, 추리, IT, 로맨드로 제한한다
   한 명의 회원은 여러권 책을 빌릴 수 있다
   
### 개념적 설계 : 현실 세계 -> 개념 모델로 변환하는 단계(ERD 작성, DBMS 독립적)
      엔티티 도출, 속성 도출, 관계 설정, 식별자 결정

   [회원] 1 - N [도서]
   엔티티 : 회원, 도서
   속성   회원 : 회원번호, 이름, 나이, 핸드폰번호, 주소
      도서 : 도서번호, 책이름, 장르
   관계 : 회원과 도서는 1:N 관계
   식별자 : 회원번호, 도서번호

### 논리적 설계 : 개념 모델 -> 테이블 구조로 변환(자료형정의, 테이블 설계, 제약조건-PK, FK, 무결성 규칙 정의)
   회원            도서
   회원번호   PK   정수      도서번호   PK   정수
   이름      문자      책이름      문자
   나이      정수      장르      문자
   전화번호      문자      회원번호 FK   정수
   주소      문자
   
### 물리적 설계 : 논리 모델 -> DBMS에 맞게 구현(제약조건설, 시퀀스)
   TBL_MEMBER
   MEMBER_NUMBER   NUMBER      PK
   MEMBER_NAME   VARCHAR2(30)   NOT NULL
   MEMBER_AGE   NUMBER      
   MEMBER_PHONE   VARCHAR2(20)   UNIQUE, NOT NULL
   MEMBER_ADDRESS   VARCHAR2(100)   NOT NULL

   TBL_BOOK
   BOOK_NUMBER   NUMBER      PK
   BOOK_TITLE   VARCHAR2(100)   NOT NULL
   BOOK_GENRE    VARCHAR2(20)   CHECK   IN(인문학, 추리, IT, 로맨스)
   MEMBER_NUMBER   NUMBER      FK


병원에서 환자와 진료 정보를 관리하려고 한다.

환자의 정보는 환자번호, 이름, 주민번호, 주소, 전화번호이다.
의사의 정보는 의사번호, 이름, 진료과이다.
진료 정보는 진료번호, 진료일, 진단내용이다.

한 명의 환자는 여러 번 진료를 받을 수 있다.
한 명의 의사는 여러 환자를 진료할 수 있다.


### 요구사항 분석 
   환자, 의사, 진료 정보를 관리한다
   환자 - 의사 = N:M 관계
   환자 - 진료 = 1:N
   의사 - 진료 = 1:N
   
      환자 - 진료 - 의사
      1   : N  N : 1
   환자는 환자번호, 이름, 주민번호, 주소, 전화번호가 필요하다(가진다)
   의사는 의사번호, 이름, 진료과가 필요하다
   진료는 진료번호, 진료일, 진단내용가 필요하다

### 개념적 설계
   [환자] 1 - N[진료]N - 1 [의사]

   엔티티 : 환자, 진료, 의사
   속성 정의
      환자 : 환자번호, 이름, 주민번호, 주소, 전화번호
      의사 : 의사번호, 이름, 진료과
      진료 : 진료번호, 진료일, 진단내용
   식별자 결정 : 환자 번호, 의사번호, 진료번호

### 논리적 설계
   환자
   환자번호   정수   PK
   이름   문자
   주민번호   문자
   주소   문자
   전화번호   문자

   의사
   의사번호   정수   PK
   이름   문자
   진료과   문자

   진료
   진료번호   정수   PK
   진료일   날짜
   진단내용   문자
   환자번호   정수   FK
   의사번호    정수   FK

2. 이상현상
	DDL, DML 개념이 있어야한다
	테이블에 컬럼을 무엇을 넣어야할지, 하나의 테이블을 두개로 분리할지 고민하는 작업
	
	무결성의 특징	일관성, 유효성, 정확성을 지켜도 정규화를 하지 않으면 나중에 테이블간 문제가 발생할 수 있다
	1차 ~ 6차까지 정규화를 분리하여 진행한다
	3차까지만 진행

1) 데이터베이스에 정규화가 필요한 이유
	데이터베이스를 잘 못 설계하면 블필요한 데이터의 중복으로 인해 공간이 낭비된다
	이러한 현상을 이상(Anomaly)현상이라고 한다

2) 이상현상
   	데이터베이스 설계가 잘못되어 발생하는 문제

   	직원
  	===================================================
   	사원번호(pk)   이름   생년월일      부서정보         급여
   	1      홍길동   2010-12-11   영업부, 서울시..12312   300
   	2      강감찬   2011-02-04   개발부, 서울시..02322   250
   	3      신짱아   2008-05-09   영업부, 서울시..01234   200
   	4      홍길동   2010-12-11   영업부, 서울시..12312   500

3) 이상현상의 종류
- 삽입이상(Insertion Anomaly)
   	새로운 데이터를 삽입하기 위해 불필요한 데이터도 같이 삽입해야하는 문제
   	새로운 부서를 추가하려고 할 때 해당 부서에 소속된 직원이 아직 없다면 삽입할 수 없다
   	마케팅부, 서울시..02322   추가하려고할 때 소속된 직원이 없어서 추가하지 못하는 문제가 발생함
            부서를 등록하기 위해 다른 직원을 임의로 채워넣어야하는 문제

- 갱신이상(Update Anomaly)
   	중복 행 중에서 일부만 변경하여 데이터가 불일치하는 모순의 문제
   	영업부, 서울시 12312 부서정보가 여러번 반복되어 저장됨
   	이름이 같은 홍길동 사원(사원번호 1, 4)가 있는데 동명이인인지, 중복인지 판단이 불가(기본키만으로는 확인 불가)
   

- 삭제이상(Deletion Anomaly)
   	행을 삭제했을 때 필요한 데이터도 같이 삭제되는 문제
   	특정 직원을 삭제하면 부서 정보도 같이 삭제되는 문제

	직원테이블
	회원번호	이름	부서	프로젝트코드	급여	부서별명수
	1111	홍길동	개발팀	abc0001		300	4
	1111	홍길동	개발팀	def1121		200	4
	1111	홍길동	개발팀	asd0111		400	4
	3333	이유리	기획팀	efg0101		500	2
	4444	박웅이	디자인팀	ghi9999		300	3

- 삽입이상
	담당 프로젝트가 정해지지 않은 사원이 있다면 프로젝트 코드에 NULL을 작성할 수 없다면 테이블에 추가될 수 없다
	미정 프로젝트 코드를 따로 만들어서 삽입해야한다
	
- 갱신이상
	한명의 사원은 하나의 부서에만 속할 수 있다
	만약 홍길동이라는 사원이 보안팀으로 부서를 옮길 시 3개 행을 모두 갱신해주지 않는다면 개발팀인지 보안팀인지 알 수 없다

- 삭제이상
	박웅이 사원이 담당한 프로젝트를 박살내서 드랍되면 박웅이 행을 모두 삭제해야한다

4) 함수적 종속
	이러한 이상 현상을 예방하고자 정규화를 진행한다
	정규화를 진행하기 위해서는 각 컬럼간의 관계성을 파악한다
	이 관련성을 함수적 종속성(Funtion Dependency)이라고 한다
	따라서 하나의 테이블에서는 반드시 하나의 함수적 종속성만 존재하도록 정규화를 한다

	y = 2x 함수가 있을 때 x가 무엇이냐에 따라 y가 결정된다
	x를 결정자, y를 종속자라고 한다
	x -> y
	x의 값이 1 일 때 반드시 y는 2가 나온다
	이렇게 x에 대한 y값이 항상 하나인 경우를 함수 종속이라고 한다

	생일을 알면 나이를 알 수 있다 => 나이컬럼은 생일컬럼에 함수 종속이다

3. 정규화(Nomarlization)
	삽입/삭제/갱신 이상현상을 제거하기 위한 작업
	데이터의 중복을 최소화하는데 목적이 있다
	6차 정규화까지 있으나 3차 정규화까지만 진행한다
	
1) 1차정규화(1NF-First Nomral Form)
	테이블의 모든 컬럼의 값은 원자값(단일값)을 갖도록 분해하여 중복을 제거한다
	반복되는 그룹을 별도의 테이블로 분리해야한다

	상품명
	바지1, 바지2, 바지3 => 1차정규화 위반

	상품명1	상품명2	상품명3
	바지1	바지2	바지3

  	직원
   	===================================================
   	사원번호(pk)   이름   생년월일      부서정보         급여
   	1      홍길동   2010-12-11   영업부, 서울시..12312   300
  	2      강감찬   2011-02-04   개발부, 서울시..02322   250
  	3      신짱아   2008-05-09   영업부, 서울시..01234   200
  	4      홍길동   2010-12-11   영업부, 서울시..12312   500

	직원 
	 사원번호(PK)   이름   생년월일      급여   부서번호(FK)
   	1      홍길동   2010-12-11   300
   	2      강감찬   2011-02-04   250
   	3      신짱아   2008-05-09   200
   	4      홍길동   2010-12-11   500

	부서
	부서번호(PK)   부서명   부서주소      
  	1      	영업부   	서울시..12312
   	2      	개발부   	서울시..02322
   	3      	영업부  	서울시..01234
2) 2차정규화(2NF)
	1차정규화를 만족해야한다
	기본키가 복합키일 경우, 부분함수 종속을 제거해야한다
	부분적 종속을 제거하여 테이블을 분해한다
	 과자
   	이름(PK)   맛(PK)   가격   제조사
   	포카칩   기본맛   2500   오리온
   	포카칩   어니언맛   2500   오리온
   	포테토칩   오리지널   2400   농심
   	포테토칩   어니언맛   2400   농심

   	이름만 알아도 제조사를 알 수 있다
   	조합키를 제외한 가격과 제조사 컬럼을 본다
   	가격 컬럼은 이름, 맛 알아야만 알 수 있다
   	제조사 컬럼은 이름만 알아도 확인할 수 있다
   	=> 조합키에 일부부에만 종속된다

   	과자
   	이름PK   맛PK   가격
   	포카칩   기본맛   2500
   	포카칩   어니언맛   2500
   	포테토칩   오리지널   2400
   	포테토칩   어니언   2400

   	제조사
   	이름PK   제조사
   	포카칩   오리온
   	포테토칩   농심

   	직원
   	사원번호(PK)   이름   생년월일      급여   부서번호(FK)
   	1      홍길동   2010-12-11   300
   	2      강감찬   2011-02-04   250
   	3      신짱아   2008-05-09   200
   	4      홍길동   2010-12-11   500

   	부서
   	부서번호(PK)   부서명   부서주소      
   	1      영업부   서울시..12312
   	2      개발부   서울시..02322
   	3      영업부   서울시..01234

3) 3차 정규화(3NF)
	이행적 함수를 제거하여 테이블을 분해(분리한다
	다른 컬럼(비주요컬럼)이 기본키가 아닌 컬럼에 종속되는 경우 해당 컬럼들을 새로운 테이블로 분리하여 관계를 정리한다

+) 이행적 종속
	A를 알면 B를 알고, B를 알면 C를 알 때
	A만 알아도 C를 알 수 있는 관계
	A -> B, B -> C
	A -> C

---------------------------------------------------------------------------

정규화단계
- 1차 정규화 (1NF:First Normal Form)
	모든 컬럼은 원자값만 가져야한다
	- 반복 그룹 x, 다중값 x, 하나의 칸에는 하나의 값만 있어야한다

- 2차 정규화 (2NF:Second Normal Form)
	부분 함수 종속 제거
	PK가 복합키일 때만 의미 있음 => 기본키 일부에만 종속된 컬럼 제거
	PK(학번, 과목) 이름 -> 학번 둘중 하나만 봤을 때 알 수 있으면 테이블 나눠라
		이름 -< 학번만 보면 알 수 있다
	학생테이블로 분리
- 3차 정규화 (3NF:Third Normal Form)
	이행 함수 종속 제거
	A -> B -> C
	
	학번 학과 학과전화번호
	학과 테이블로 분리

- BCNF(보이스-코드 정규화)
	3.5차 정규화
	모든 결정자는 후보키여야한다(결정자 : 다른 컬럼을 결정하는 컬럼)
	3NF보다 엄격

- 4차 정규화(4NF:Fourth Normal Form)
	다치 종속 제거
	하나의 테이블에 독립적인 여러 관계 x

	학생 -> 과목
	학생 -> 동아리

- 5차 정규화(5NF:Fifth Normal Form)
	조인 종속 제거
	테이블로 분해 후 다시 JOIN 가능해야함

- 6차 정규화(6NF:Sixth Normal Form)
	모든 속성을 완전히 분해(최소단위분해)
	데이터웨어하우스용

1차 : 원자    ────┐
2차 : 부분	│
3차 : 이행	│
BCNF : 결정자 ────┤ 원부이결다조분
4차 : 다치	│
5차 : 조인	│
6차 : 분해    ────┘

+) 반정규화(Denormalization / 부분 비정규화)
	성능 향상을 위해 일부러 다시 합치는 것
	정규화 -> JOIN 많아짐 -> 성능저하, 느려짐
	
	목적 : 조회속도 향상, JOIN 감소, 성능 개선

	단점 : 중복 발생, 수정 어려움

+) 비정규화(Unnormalization / 완전 비정규화)	
	정규화를 거의 안하고 처음부터 크게 만드는 것		=> 중복 감수, 성능 올림

	목적 : 초고속 조회, 단순 구조
	
	단점 : 중복 심함, 오류 많음, 유지보수 힘듦

+) 정규화 / 반정규화 / 비정규화

	정규화	반정규화	비정규화
목적	무결성	성능	속도
중복	없음	일부	많음
JOIN	많음	줄임	거의없음
안정성	높음	보통	낮음

-----------------------------------------------------------------------
4. DML2
	관계를 맺은 테이블에 DML 사용
	
5. 시퀀스(Sequence)
	오라클에서 중복되지 않는 값들을 자동으로 순차적으로 생성해주는 것
	보통 PK값에 중복값을 방지하기 위해 사용한다

1) 시퀀스 생성
	CREATE SEQUNCE 시퀀스명;

	여러 옵션이 존재
	START WITH 시작숫자, INCREMENT BY 증감숫자, NOCYCLE, NOCACHE, ...

	START WITH 	시작번호
	INCREMENT BY 	증가값
	MAXVALUE 	최대값
	MINVALUE 	최소값
	CYCLE		반복
	NOCYCLE 	반복 X
	CACHE 		메모리 저장
	NOCACHE 	메모리에 저장 X

2) 시퀀스 삭제
	DROP SEQUNCE 시퀀스명;

3) 시퀀스 사용
	시퀀스명.NEXTVAL

6. 집계함수와 GROUP BY, HAVING
1) 집계함수(Aggregate, Function)
	여러행을 하나의 결과값으로 계산하는 함수
	GROUP BY와 자주 함께 사용
	기본적으로 NULL 제외하고 계산
	집계함수의 결과는 행이 1개(단일행!!)
	
2) 집계함수 종류
	COUNT(*)	NULL 포함 전체 행 수
	COUNT(컬럼)	NULL 제외 개수
	SUM([DISTINCT | ALL] 표현식)		합계
	AVG([DISTINCT | ALL] 표현식)		평균
	MAX([DISTINCT | ALL] 표현식)		최대값
	MIN([DISTINCT | ALL] 표현식)		최소값
	STDEV([DISTINCT | ALL] 표현식)		표준편차
	VARIANCE([DISTINCT | ALL] 표현식)	분산

+) SELECT문 해석 및 작성 순서
   	작성 순서 : SELECT -> FROM -> WHERE -> GROUP BY -> HAVING -> ORDER BY
   	해석 순서 : FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> ORDER BY

   	SELECT [DISTINCT] 컬럼명 [AS 별칭]
   	FROM 테이블명
   	WHERE 조건식
   	GROUP BY 그룹화 기준 컬럼
   	HAVING 그룹 조건식(집계함수 사용 가능)
   	ORDER BY 정렬 기준 컬럼 [ASC / DESC];

   	SELECT 절에서 없는 컬럼 ORDER BY 절 사용 가능
  	GROUP BY 절에서 그룹핑 기준을 정의하면 GROUP BY절의 그룹핑 기준에 사용된 컬럼과 
      	집계함수에 사용될 수 있는 숫자형 데이터 컬럼들의 집합을 새로 만듦

3) GROUP BY, HAVING 절
   	GROUP BY 절은 특정 컬럼에 있는 값을 그룹으로 묶어서 데이터를 집계한다
   	ORDER BY 절과 동일하게 SELECT문에서 사용되며 위치는 WHERE절 다음, ORDER BY절 이전에 작성된다
   	HAVING 절은 GROUP BY 다음에 사용할 수 있으며 SELECT의 WHERE절처럼 GROUP BY의 HAVING 조건을 걸어준다

- GROUP BY : 같은 값을 가지는 행들을 그룹화하여 집계 연산을 수행할 때 사용
- HAVING : GROUP BY로 묶은 결과에 조건을 걸고 필터링 할 때 사용

   	WHERE절은 쿼리문 전체에 조건을 걸어서 데이터를 가져오며
   	그 데이터들을 GROUP BY 로 묶어주는데 묶은 데이터에 조건이 필요하거나 집계함수를 사용해야한다면 HAVING절에 작성한다
   	WHERE절은 집계함수 사용 불가능, HAVING절은 집계함수 사용 가능
   	WHERE절에 우선적으로 처리할 조건식을 작성해야 속도가 빠르다

7. ROWNUM
	조회된 순서대로 붙는 가상번호
	SELECT 할 때 임시 생성
	ROWNUM은 반드시 1부터 시작해야한다
	정렬 전에 붙는 번호 -> 서브쿼리로 정렬을 먼저 해야한다



























