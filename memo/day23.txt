day23 (dbms 5일차)
복습 -> JOIN -> 집합 -> 서브쿼리 -> VIEW -> DCL -> TCL

0. 복습

1) 이상현상

	데이터베이스 설계가 잘못되어 발생하는 문제
	- 삽입이상 
	- 갱신이상 : 중복행 중 일부만 바뀌는것
	- 삭제이상 : 행을 삭제할 때 필요한 내용도 같이 삭제되는 것 

2) 정규화(Normalization)

	삽입/갱신/삭제 이상현상을 제거하기 위한 작업
	데이터 중복을 최소화하는 것이 목적

- 1차정규화
	테이블의 모든 컬럼의 값은 원자값을 가져야한다
	반복되는 그룹을 별도의 테이블로 분리해야한다

- 2차정규화
	1차정규화를 만족해야한다
	기본키가 복합키일 경우 부분함수 종속 제거

- 3차정규화
	이행적 함수를 제거하여 테이블을 분리한다

3) 집계함수

	그룹화된 데이터를 집계 연산을 통해 하나의 결과(행)로 얻는다
	기본적으로 NULL 제외하고 진행

	COUNT(*) NULL 포함
	COUNT(컬럼) NULL 제외
	SUM() NULL 제외
	AVG() NULL 제외
	MAX(), MIN()

4) SELECT문

	SELECT [DISTINCT] 컬럼명 [AS 별칭]
	FROM 테이블명
	WHERE 조건식
	GROUP BY 그룹화 기준 컬럼
	HAVING 그룹 조건식
	ORDER BY 정렬기준컬럼 [ASC/DESC];
	
	작성순서 : SELECT - FROM - WHERE - GROUP BY - HAVING - ORDER BY
	실행순서 : FROM - WHERE - GROUP BY - HAVING - SELECT - ORDER BY

5) ROWNUM 

	결과 행 앞에 1부터 1씩 증가하는 시퀀스를 붙여준다
	ROWNUM은 컬럼처럼 사용하면 된다
	*를 다른 컬럼과 함께 조회하게되면 소속(어디테이블인지)을 명시해야한다
	테이블에 ALIAS를 부여하고 해당 별칭은 * 앞에 명시해준다(별칭.*)

1. JOIN

	두 개 이상의 테이블을 연결하여 데이터를 검색하는 방법
	여러 테이블에 흩어져 있는 정보 중 사용자가 필요한 정보만 가져와서 가상의 테이블처럼 만들고 결과를 보여주는 것

	정규화를 통해 조회 테이블이 너무 많이 쪼개져있으면 작업이 불편하기 때문에 입력, 수정, 삭제의 성능을 향상시키기 위해서
	JOIN을 통해 합친 후 사용한다

1) JOIN의 종류

	내부 조인		공통 존재 컬럼의 값이 같은 경우를 추출하는 기법
	외부 조인		왼쪽 외부조인, 오른쪽 외부조인, 완전 외부조인
			- 왼쪽 외부조인 : 왼쪽 테이블의 모든 데이터와 오른쪽 테이블의 동일 데이터를 추출하는 기법
			- 오른쪽 외부조인 : 오른쪽 테이블의 모든 데이터와 왼쪽 테이블의 동일 데이터를 추출하는 기법
			- 완전 외부조인 : 양쪽의 모든 데이터를 추출하는 기법
	교차 조인		조인 조건이 없는 모든 데이터 조합을 추출하는 기법
	셀프 조인		자기자신에게 별칭을 지정한 후 다시 조인하는 기법

2) 내부조인

	조건이 정확히 일치하는 값만 합쳐서 조회

	SELECT A.컬럼명1, A.컬럼명2, B.컬럼명1, B.컬럼명2
	FROM 테이블명 1 A	[INNER] JOIN 테이블명2 B
	ON [조인조건] -- A.컬럼명1 = B.컬럼명1
	[WHERE 검색조건];

	SQL 실행순서 ★★★★★ 

	FROM - ON-  JOIN - WHERE - GROUP BY - HAVING - SELECT - ORDER BY

	FROM : 테이블이나 뷰의 데이터를 가져오기
	ON : JOIN절의 조건 평가
	JOIN : 지정된 조건에 따라 두 개 이상의 테이블을 조인(합치기)
	GROUP BY : 데이터 그룹화(집계함수와 주로 사용)
	HAVING : GROUP BY로 그룹화된 데이터에 대해 조건 적용
	SELECT : 조회할 컬럼을 선택(중복제거, 집계함수, 별칭
	ORDER BY : 최종결과를 정렬(별칭, ASC/DESC)

	선행 테이블의 행 개수가 작아야한다

	[도서]		[도서가격]
	책번호	책제목	책번호	가격
	1000	운영체제	1000	10000
	3000	자료구조	2000	25000
	5000	컴퓨터구조	3000	15000
			4000	20000

- 등가조인
	
	두 테이블간의 컬럼ㅁ의 값이 서로 일치할 때 ON절에 등호(=)가 있을 때
	일반적으로 PK <-> FK 관계를 이용하여 조인을 주로 사용한다
	두 테이블간의 관계가 있다면(FK가 존재한다면) 부모 테이블의 PK와 자식 테이블의 FK를 등호로 비교가 가능하기 때문에
	등가조인 사용이 가능하다

- 비등가조인
	
	두 테이블의 특정 컬럼이 일치하지 않는 경우, ON절에 등호(=)가 없을 때
	= 연산자가 아닌 BETWEEN, >, >=, <, <= 등의 연산자를 사용한다

3) 외부조인(OUTER JOIN)
	
	내부조인과는 다르게 한쪽에만 값이 있어도 테이블을 합쳐서 보여준다

- 왼쪽 외부조인 => 왼쪽 테이블 기준 / 오른쪽 테이블에 일치하는 컬럼이 없얼때는 오른쪽의 컬럼값은 NULL로 채워진다

	SELECT A.컬럼1, A.컬럼2, B.컬럼1
	FROM 테이블1 A LEFT [OUTER] JOIN 테이블2 B
	ON 조인조건
	[WHERE 검색조건];

- 오른쪽 외부조인 => 오른쪽 테이블 기준 / 왼쪽 테이블에 일치하는 컬럼이 없얼때는 왼쪽의 컬럼값은 NULL로 채워진다

	SELECT A.컬럼1, A.컬럼2, B.컬럼1
	FROM 테이블1 A RIGHT [OUTER] JOIN 테이블2 B
	ON 조인조건
	[WHERE 검색조건];
	
- 완전 외부조인 => 양쪽 모든 값을 기준 / 모든 컬럼의 값이 다 나온다
		없는 컬럼값은 null로 채워짐

	SELECT A.컬럼1, A.컬럼2, B.컬럼1
	FROM 테이블1 A FULL [OUTER] JOIN 테이블2 B
	ON 조인조건
	[WHERE 검색조건];

A.책번호	A.책이름	B.책번호  B.가격
1	A      	1   	10000
3	C      	2   	15000
4	D	3   	22000
6	E

[왼쪽 외부조인]   
A.책번호	A.책이름  B.책번호  B.가격
1	A	1	10000
3      	C	3	22000
4      	D	NULL    NULL
6     	E	NULL    NULL


[오른쪽 외부조인]
A.책번호  A.책이름  B.책번호  B.가격
1   	A  	1   	10000
NULL   	NULL    2   	15000
3   	C   	3   	22000

[완전 외부조인]
A.책번호  A.책이름  B.책번호  B.가격
1   	A   	1   	10000
NULL   	NULL  	2   	15000
3   	C   	3   	22000
4   	D   	NULL   	NULL
6   	E   	NULL   	NULL

4) 교차조인(CROSS JOIN)

	조건없이 두 테이블의 모든 조합을 생성(카디션 곱)
	
	STUDENT 3명, COURSE 2개 -> 3 X 2 = 6행

5) 셀프조인(SELF JOIN)

	하나의 테이블을 자기 자신과 조인하는 방식
	
+) 조인 사용 경우
- 내부조인 => 둘 다 있는 것만 보여준다
	도서관(회원, 대여기록)
	책 빌린 사람만 조회

- 왼쪽 외부조인 => 왼쪽은 무조건 다 보여준다 (전체 명단이 중요할 때)
	회사(직원, 부서)
	아직 부서가 정해지지않은 신입도 조회
	
- 오른쪽 외부조인 => 오른쪽은 무조건 다 보여준다
	학교(학생, 수업)
	모든 수업 목록 + 듣는 학생 => 아직 수강생이 없는 수업도 보여줘야함

- 완전 외부조인 => 양쪽 전부 다 보여준다
	쇼핑몰(회원, 주문)

- 자기자신조인, 셀프조인 => 같은 테이블끼리 연결
	회사 직원
	직원번호	직무	상사번호	이름
	100	사장	null	홍길동
	101	부장	100(사장)	신짱구
	102	팀장	101(부장)	김유리
	103	직원	102(팀장)	김철수
	104	직원	102(팀장)	이훈이

	내이름 <-> 상사이름
	직원번호	직원이름	상사번호	상사이름
	100	홍길동	null	null
	101	신짱구	100	홍길동

- 크로스 조인 => 경우의 수 전부 보여줌
	쇼핑몰 티셔츠
	색상 빨강, 노랑, 검은색, 회색
	사이즈 S, M, L

	가능한 조합 전부 만들기
	빨강-S, M, L
	노랑-S, M, L   =>  4 X 3 = 12
	...
	
2. 집합
	
	UNION : 합집합, 중복을 허용하지 않는다
	UNION ALL : 합집합, 중복을 허용한다
	INTERSECT : 교집합
	MINUS : 차집합

1) 집합연산자가 있는 이유

	데이터베이스에서 여러 쿼리의 결과를 조합하고 특정 방식으로 결과를 출력하기 위해 존재한다
	여러 테이블이나 쿼리의 결과를 효과적으로 비교, 병합, 차 구하기 등으로 처리해야하는 데이터의 요구사항 때문에 존재한다

		집합연산				WHERE 조건
쿼리 실행 방식	각 SELECT 쿼리가 독립적으로 실행	단일 쿼리로 실행
결과 처리 단계	개별 쿼리 결과를 결합 비교		조건 필터링만 수행
중복 제거 여부	UNION 중복제거, UNION ALL 중복제거 X	중복 제거는 따로 수행하지 않음
데이터 소스		여러테이블, 쿼리 조합 가능		단일 테이블에서 작동
성능		SORT, 비교 등의 추가 단계 느릴수있음	단일 조건 처리로 비교적 빠름
사용 목적		독립된 결과를 병합하거나 차집합, 교집합	단일 테이블에서 특정 조건만 필터링
		구할 때 사용		

2) 집합 연산을 써야만 하는 상황(WHERE절로는 안되는 상황)
- 서로 다른 테이블끼리 비교
	EMP테이블과 DEPT테이블 -> 하나의 WHERE 조건으로는 합칠 수 없음
	
- 조건이 겹치거나 복잡할 때
	SELECT * FROM EMP
	WHERE (SAL BETWEEN 1000 AND 2000) OR (SAL BETWEEN 10000 AND 30000);

	SELECT * FROM EMP WHERE SAL BETWEEN 1000 AND 2000
	UNION
	SELECT * FROM EMP WHERE SAL BETWEEN 10000 AND 30000

+) 활용
	상황					이유
	서로 다른 조건 결과를 한번에 출력하고 싶을 때	조건이 복잡하거나 명확한 구분이 필요한 경우가 있기 때문 UNION, UNION ALL
	서로 다른 테이블의 결과를 병합			조인 대신 간단히 병합할 때			UNION
	중복 데이터도 모두 보고싶을 때			성능이 좋고 확인하기 쉽기 때문에			UNION ALL
	공통 데이터만 추출할 때			두 조건을 동시에 만족하는 경우			INTERSECT
	하나의 쿼리 결과에서 다른 쿼리 결과를 빼야할 때	제외 조건을 명확하게 할 수 있기 때문		MINUS

3. 서브쿼리(SUB QUERY)
	
	하나의 쿼리 내에 작성하는 또 다른 쿼리
	서브쿼리의 위치에 따른 종류
		- FROM 절	: INLINE VIEW
		- SELECT 절	: SCALAR
		- WHERE 절	: SUB QUERY
- 인라인 뷰
	FROM 절 안에 또 다른 쿼리문을 작성한다
	서브쿼리의 결과를 가상 테이블처럼 사용한다

- 스칼라 서브쿼리
	SELECT 절 안에 또 다른 쿼리문을 작성한다
	단일컬럼, 단일 행을 반환한다(1개의 값으로 사용)
	
- 서브쿼리
	WHERE 절 또는 HAVING 절 안에 또 다른 쿼리를 작성한다

연관 서브쿼리(Correlated Subquery)
	서브쿼리가 메인 쿼리의 컬럼을 참조한다
	메인쿼리의 각 행마다 반복 실행된다
	
비연관 서브쿼리(Non-Correlated Subquery)
	서브쿼리가 메인 쿼리의 컬럼을 사용하지 않느다
	메인쿼리와 독립적으로 실행가능하다
	일반적으로 한 번만 실행된다

단일 행 서브쿼리(Single-Row Subquery)
	하나의 값만 반환
	연산자 : =, >, <, >=, <=, <>(!=)

다중 행 서브쿼리(Multi-Row Subquery)
	여러 행(값) 반환
	연산자 : IN, ANY, ALL, EXISTS, SOME

* 서브쿼리 : SQL 안에 들어있는 SQL
	SELECT ...
	FROM ...
	WHERE 컬럼 = (SELECT ...);

- 일반 서브쿼리
	안쪽 실행 -> 결과 저장 -> 바깥 실행

메인쿼리 행의 수 > 서브쿼리 행의 수 O
메인쿼리 행의 수 < 서브쿼리 행의 수 X
그룹으로 묶은 행의 수보다 적은행을 같이 조회하는 것 가능하다









