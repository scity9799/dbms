-- 2번 : 테이블 관계 맺기(FK 제약조건)

-- FK : 테이블 간의 관계를 맺기위해 사용

-- 1) 기본구조 : 회원 1명 -> 주문 여러개 (1 : N)
CREATE TABLE TBL_USER_TEST(
	USER_ID NUMBER,
	USER_NAME VARCHAR2(30),
	CONSTRAINT PK_USER_TEST PRIMARY KEY(USER_ID)
);

SELECT * FROM TBL_USER_TEST;

CREATE TABLE TBL_ORDER_TEST(
	ORDER_ID NUMBER,
	USER_ID NUMBER,
	CONSTRAINT PK_ORDER_TEST PRIMARY KEY(ORDER_ID),
	CONSTRAINT FK_ORDER_USER FOREIGN KEY(USER_ID) REFERENCES TBL_USER_TEST(USER_ID)
-- FK 제약 조건 추가 
-- CONSTRAINT 제약조건명 FOREIGN KEY(현재 테이블 컬럼명) REFERNCES 참조할 테이블명(참조할 테이블의 컬럼명) 
);

-- FK 제약조건 전 값 넣고 확인
INSERT INTO TBL_USER_TEST
--VALUES(1,'신짱구');
VALUES(2,'김철수');


INSERT INTO TBL_ORDER_TEST
--VALUES(1,1);
--VALUES(2,2);
VALUES(3,3);

-- 각 테이블 확인 후 테이블 삭제 진행 -> 테이블에 FK 제약조건 추가
DELETE FROM TBL_USER_TEST;
DELETE FROM TBL_ORDER_TEST;
DROP TABLE TBL_ORDER_TEST;

-- FK 제약조건 추가 후 값 삽입
INSERT INTO TBL_ORDER_TEST 
VALUES(1,1);

-- FK가 참조하는 테이블의 값부터 넣는다
INSERT INTO TBL_USER_TEST 
--VALUES(1, '서서울');
--VALUES(2, '서한강');
--VALUES(3, '김소연');
VALUES(4, '정의동');

INSERT INTO TBL_ORDER_TEST 
VALUES(1,1);
--INSERT INTO TBL_ORDER_TEST 
--VALUES(2,5); -- 부모 테이블에 없는 값을 넣으려고하면 오류 발생


SELECT * FROM  TBL_USER_TEST;
SELECT * FROM  TBL_ORDER_TEST;

-- 자동차 테이블 생성 TBL_CAR
-- 자동차 번호 CAR_NUMBER NUMBER
-- 자동차 이름 CAR_NAME VARCHAR2(100)
-- 자동차 브랜드 CAR_BRAND VARCHAR2(100)
-- 출시 날짜 CAR_RELEASE_DATE DATE
-- 색상	CAR_COLOR VARCHAR2(100)
-- 가격	CAR_PRICE NUMBER

CREATE TABLE TBL_CAR(
	CAR_NUMBER NUMBER,
	CAR_NAME VARCHAR2(100),
	CAR_BRAND VARCHAR2(100),
	CAR_RELEASE_DATE DATE,
	CAR_COLOR VARCHAR2(100),
	CAR_PRICE NUMBER
);

SELECT * FROM TBL_CAR;

-- TBL_CAR 테이블은 6개의 컬럼을 가지고 있다
-- PK : 중복 X, NULL X => CAR_NUMBER

ALTER TABLE TBL_CAR
ADD CONSTRAINT PK_CAR PRIMARY KEY(CAR_NUMBER);

/*
 * ALTER TABLE TBL_CAR : TBL_CAR 테이블을 수정하겠다
 * ADD : 추가한다
 * CONSTRAINT : 제약조건
 * PK_CAR : 제약조건이름
 * PRIMARY KEY(CAR_NUMBER) : PK 제약조건을 (CAR_NUMBER) 컬럼에
 * 
 * PK_CAR 이름으로 PK 제약조건을 CAR_NUMBER 컬럼에 추가하겠다
 * */

--ALTER TABLE TBL_CAR DROP CONSTRAINT
--PK_CAR; -- 제약조건 삭제 시 사용

SELECT * FROM TBL_CAR;

-- 학교테이블(부모테이블) / 학생테이블(자식테이블)

CREATE TABLE TBL_SCHOOL(
	SCHOOL_NUMBER NUMBER,
	SCHOOL_NAME VARCHAR2(100),
	CONSTRAINT PK_SCHOOL PRIMARY KEY(SCHOOL_NUMBER)
);
--DROP TABLE TBL_STUDENT ;
CREATE TABLE TBL_STUDENT(
	STUDENT_NUMBER NUMBER,
	STUDENT_NAME VARCHAR2(100),
	STUDENT_AGE NUMBER,
	SCHOOL_NUMBER NUMBER,
	CONSTRAINT PK_STUDENT PRIMARY KEY(STUDENT_NUMBER),
	CONSTRAINT FK_STUDENT_SCHOOL FOREIGN KEY(SCHOOL_NUMBER) REFERENCES TBL_SCHOOL(SCHOOL_NUMBER)
);

SELECT * FROM TBL_STUDENT;
SELECT * FROM TBL_SCHOOL;

INSERT INTO TBL_SCHOOL 
--VALUES(1, 'JAVA 고등학교');
--VALUES(2, 'DBMS 고등학교');
--VALUES(3, 'KOREA 고등학교');
VALUES(4, '한국 고등학교');

INSERT INTO TBL_STUDENT 
--VALUES(1,'짱구', 10, 1);
--VALUES(2,'철수', 17, 1);
--VALUES(3,'유리', 17, 2);
--VALUES(4,'맹구', 17, NULL);
--VALUES(5,'훈이', 17, 5); -- 오류발생 FK에 SCHOOL_NUMBER에 존재하지 않은 값을 저장하려하면 오류발생
--VALUES(5,'훈이', 17, 3);
VALUES(6,'치타', 19, 2);

SELECT * FROM TBL_STUDENT
ORDER BY STUDENT_NUMBER ;

-- 나이가 18살인 학생만 조회
-- 조건 : STUDENT_AGE = 18
SELECT STUDENT_AGE 나이
FROM TBL_STUDENT
WHERE STUDENT_AGE = 18;

-- 학교 번호가 1번인 학생만 조회
-- 조건 : SCHOOL_NUMBER = 1
SELECT SCHOOL_NUMBER, STUDENT_NAME 
FROM TBL_STUDENT
WHERE SCHOOL_NUMBER = 1;

-- 학교가 없는 학생만 조회
SELECT SCHOOL_NUMBER, STUDENT_NAME 
FROM TBL_STUDENT
WHERE SCHOOL_NUMBER IS NULL;

-- 19살이면서 학교번호가 2번인 학생만 조회
SELECT STUDENT_AGE, SCHOOL_NUMBER, STUDENT_NAME 
FROM TBL_STUDENT
WHERE SCHOOL_NUMBER = 2 AND STUDENT_AGE = 19;

-- 17~18살인 학생 조회
SELECT STUDENT_AGE, STUDENT_NAME 
FROM TBL_STUDENT
WHERE STUDENT_AGE BETWEEN 17 AND 18;

-- 이름에 구가 들어간 학생 조회
SELECT STUDENT_NAME
FROM TBL_STUDENT
WHERE STUDENT_NAME LIKE '%구%';

DELETE FROM TBL_STUDENT ;
DELETE FROM TBL_SCHOOL  ;

INSERT INTO TBL_SCHOOL 
--VALUES(1, '코리아고등학교');
--VALUES(2, '코리아IT고등학교');
--VALUES(3, '한국고등학교');
--VALUES(1, '한국IT고등학교'); -- SCHOOL_NUMBER는 PK로 설정된 컬럼이기 때문에 중복값 불가
--VALUES(NULL, NULL); -- SCHOOL_NUMBER는 PK로 설정된 컬럼이므로 NULL 불가
VALUES(4, NULL);

INSERT INTO TBL_STUDENT 
--VALUES(1, '짱구', 17, 1);
--VALUES(2, '철수', 17, 1); -- FK 중복 가능
--VALUES(3, '유리', 17, 2);
--VALUES(3, '맹구', 17, 3); -- PK 중복 불가
--VALUES(4, '맹구', 17, 3); 
--VALUES(5, '훈이', 17, NULL); -- FK NULL 가능(최대한 안쓰는게 좋음)
VALUES(6, NULL, NULL, NULL);

SELECT * FROM TBL_STUDENT;
-- FK에 없는 값을 넣으면 오류 발생, FK에 중복값 가능, NULL 가능
-- PK는 중복값 불가, NULL 불가

-- STUDENT 테이블에 STUDENT_NAME 컬럼에 UNIQUE 제약조건 추가
ALTER TABLE TBL_STUDENT 
ADD CONSTRAINT UK_STUDENT_NAME UNIQUE (STUDENT_NAME);

INSERT INTO TBL_STUDENT 
--VALUES(7, NULL, NULL, NULL); -- UNIQUE 제약조건있으면 중복값 불가, NULL 가능
--VALUES(8, '짱구', NULL, NULL);

SELECT * FROM TBL_STUDENT;
SELECT * FROM TBL_SCHOOL;

-- 삭제
-- 학교 번호가 없는 학생 데이터만 삭제
DELETE FROM TBL_STUDENT 
WHERE SCHOOL_NUMBER IS NULL;

-- 이름이 맹구인 학생만 삭제
DELETE FROM TBL_STUDENT 
WHERE STUDENT_NAME = '맹구';

SELECT * FROM TBL_SCHOOL;
-- 학교번호가 1번인 행 삭제
DELETE  FROM TBL_SCHOOL
WHERE SCHOOL_NUMBER = 1; -- 자식테이블이(TBL_STUDENT)이 1번 학교를 참조하고 있어서 삭제 불가
-- 외래키(FK)	데이터 무결성 보호용(고아 데이터 방지용)

-- 자식테이블의 값을 바꾸거나 삭제한다
-- 방법 1) NULL로 값을 변경하고 참조를 끊는다
UPDATE TBL_STUDENT
SET SCHOOL_NUMBER = NULL
WHERE SCHOOL_NUMBER = 1;

-- 다시 삭제 진행
DELETE FROM TBL_SCHOOL 
WHERE SCHOOL_NUMBER = 1; -- 참조하고 있지 않으므로 삭제 가능

-- 방법 2) 자식부터 삭제
DELETE FROM TBL_STUDENT 
WHERE SCHOOL_NUMBER = 2;

-- 그다음 학교 삭제
DELETE FROM TBL_SCHOOL
WHERE SCHOOL_NUMBER = 2;

SELECT * FROM TBL_STUDENT;
SELECT * FROM TBL_SCHOOL;

-- FK 옵션

